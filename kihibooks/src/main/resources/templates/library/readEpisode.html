<!DOCTYPE html>
<html
    xmlns:th="http://www.thymeleaf.org"
    xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
    xmlns:sec="http://www.thymeleaf.org/extras/spring-security"
    layout:decorate="~{layout/layout.html}">
<head>
    <meta charset="UTF-8">
    <title>EPUB 읽기</title>
    <style>
        #epub-area {
            width: 800px;
            height: 600px; /* 고정 높이 설정 */
            margin: 20px auto;
            border: 2px solid #ddd; /* 테두리 색상 변경 */
            background-color: #f9f9f9; /* 배경색 변경 */
            overflow-y: hidden; /* Epub.js가 내부적으로 스크롤을 처리하므로 hidden */
            position: relative;
        }
        .series-container {
            margin-top: 30px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            text-align: center; /* 버튼 중앙 정렬을 위해 추가 */
        }
        #extracted-text-area {
            margin-top: 20px;
            border: 1px dashed #ccc;
            padding: 10px;
            /* white-space: pre-wrap; 제거 - HTML을 렌더링할 것이므로 */
            max-height: 500px; /* 높이 설정 유지 */
            overflow-y: auto; /* 내용이 넘칠 경우 스크롤바 표시 */
            text-align: left; /* 텍스트는 왼쪽 정렬 */
            min-height: 500px; /* 최소 높이 유지 */
            background-color: #ffffff; /* 배경색 설정 */
            box-sizing: border-box; /* 패딩이 너비에 포함되도록 */
        }
        /* 추출된 HTML 내의 SVG Image 스타일 */
        #extracted-text-area svg image {
            max-width: 100%; /* 이미지가 부모 컨테이너를 넘지 않도록 */
            height: auto;
            display: block; /* 이미지 하단 여백 제거 */
            margin: 5px auto; /* 이미지 중앙 정렬 및 상하 여백 */
            border: 1px solid #eee; /* 이미지가 있는지 확인하기 위한 테두리 */
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #0056b3;
        }
        /* 기존 스타일 유지 및 필요한 경우 조정 */
        .content-management-page h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            border-bottom: 2px solid #ff7f50;
            padding-bottom: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <main layout:fragment="content">
        <div class="container content-management-page">
            <h2 class="mb-3">📖 EPUB 읽기</h2>
            <p>에피소드 코드: <span th:text="${epCode}"></span></p>
            <input type="hidden" th:value="${epCode}" id="epCode">
            <input type="hidden" th:value="${boCode}" id="boCode">

            <div class="series-container">
                <div id="extracted-text-area">
                    EPUB 내용 추출 결과가 여기에 HTML 형식으로 표시됩니다.
                    (이미지 로딩 여부는 콘솔을 확인해주세요)
                </div>

                <div id="epub-area"></div>
                <div style="margin-top: 10px;">
                    <button id="prevBtn">이전 페이지</button>
                    <button id="nextBtn">다음 페이지</button>
                </div>
            </div>
        </div>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        
        <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
        
        <script src="https://unpkg.com/xmldom@0.6.0/dom-parser.js"></script>
        
        <script src="/resources/static/js/epub.min.js"></script>

        <script>
            console.log(">>> 스크립트 로드 완료! 디버깅 정보 <<<");
            console.log("JSZip 객체 타입:", typeof JSZip); 
            console.log("DOMParser 객체 타입:", typeof DOMParser); 
            console.log("Epub.js 스크립트 로드 직후 ePub 객체 타입:", typeof ePub); 
            console.log("Epub.js 스크립트 로드 직후 window.ePub 객체 타입:", typeof window.ePub); 
            console.log(">>> 디버깅 정보 끝 <<<");
        </script>

        <script th:inline="javascript">
            // 파일 확장자에 따른 MIME 타입 반환 헬퍼 함수
            function getMimeType(filename) {
                const ext = filename.split('.').pop().toLowerCase();
                switch (ext) {
                    case 'jpg':
                    case 'jpeg': return 'image/jpeg';
                    case 'png': return 'image/png';
                    case 'gif': return 'image/gif';
                    case 'svg': return 'image/svg+xml';
                    case 'bmp': return 'image/bmp';
                    case 'webp': return 'image/webp';
                    default: return 'application/octet-stream'; // 알 수 없는 경우 기본값
                }
            }

            const epCode = $("#epCode").val();
            const boCode = $("#boCode").val();
            console.log("가져온 에피소드 코드:", epCode);
            console.log("가져온 책 코드:", boCode);

            const epubFileUrl = "/file/" + boCode + "/epubs/" + epCode + ".epub";
            console.log("EPUB 파일을 가져올 URL:", epubFileUrl);

            try {
                const EpubConstructor = typeof ePub !== 'undefined' ? ePub : Epub;
                if (typeof EpubConstructor !== 'function') {
                    throw new Error("ePub.js 라이브러리가 전역에 'ePub' 또는 'Epub' 객체를 정의하지 못했습니다.");
                }

                const book = new EpubConstructor(epubFileUrl);
                console.log("Epub 객체 생성됨:", book);

                book.ready.then(function() {
                    console.log("책 로드 및 파싱 완료!");

                    const rendition = book.renderTo("epub-area", {
                        width: "800px",
                        height: "600px",
                        flow: "scrolled-doc",
                        manager: "default"
                    });
                    rendition.display();

                    document.getElementById("nextBtn").addEventListener("click", function(){
                        rendition.next();
                        console.log("다음 페이지로 이동");
                    });
                    document.getElementById("prevBtn").addEventListener("click", function(){
                        rendition.prev();
                        console.log("이전 페이지로 이동");
                    });

                    const spineItems = book.spine.items;
                    console.log("책에 있는 섹션/챕터 수:", spineItems.length);
                    
                    const htmlExtractionPromises = spineItems.map(function(item) {
                        console.log(`--- 섹션 처리 시작: ${item.href} ---`);

                        return book.load(item.href)
                            .then(loadedContent => { 
                                let extractedHtml = "";
                                
                                if (loadedContent && typeof loadedContent.documentElement === 'object' && loadedContent.documentElement.nodeName) {
                                    const serializer = new XMLSerializer();
                                    extractedHtml = serializer.serializeToString(loadedContent);

                                    console.log(`DEBUG: Loaded content is XMLDocument object for ${item.href}`);

                                    // head 및 title 태그 내용 제거
                                    extractedHtml = extractedHtml.replace(/<head[^>]*>[\s\S]*?<\/head>/i, '');
                                    extractedHtml = extractedHtml.replace(/<title[^>]*>[\s\S]*?<\/title>/i, '');

                                    const tempDiv = document.createElement('div');
                                    tempDiv.innerHTML = extractedHtml; // Parse the HTML string into a temporary DOM

                                    // SVG 내부의 <image> 태그 xlink:href 속성 처리
                                    const svgImages = tempDiv.querySelectorAll('svg image');
                                    console.log(`DEBUG: Found ${svgImages.length} svg image elements in tempDiv (XMLDocument branch).`);

                                    // 각 이미지 처리는 비동기이므로 Promise.all로 묶습니다.
                                    const imageProcessingPromises = [];

                                    svgImages.forEach((svgImg, index) => {
                                        const originalXlinkHref = svgImg.getAttributeNS('http://www.w3.org/1999/xlink', 'href'); 
                                        console.log(`DEBUG:   SVG Image #${index} - Original outerHTML BEFORE change: ${svgImg.outerHTML}`);

                                        // 이미 http나 data:로 시작하는 경우 중복 처리 방지
                                        if (originalXlinkHref && !originalXlinkHref.startsWith('http') && !originalXlinkHref.startsWith('data:')) {
                                            let internalResolvedPath;
                                            try {
                                                // 1. item.href를 기준으로 상대 경로를 먼저 EPUB 내부의 '절대' 경로화
                                                internalResolvedPath = new URL(originalXlinkHref, item.href).toString();
                                            } catch (e) {
                                                console.error(`URL 해석 오류 (originalXlinkHref: ${originalXlinkHref}, item.href: ${item.href}):`, e);
                                                return; // 이 이미지 처리를 건너뛰고 다음 이미지로 넘어감
                                            }
                                            
                                            console.log(`DEBUG:   SVG Image #${index} - 내부 해결된 경로: ${internalResolvedPath}`);
                                            const mimeType = getMimeType(internalResolvedPath); // MIME 타입 추론

                                            // 2. book.archive.getBase64()를 통해 이미지 Base64 데이터 직접 얻기 (비동기)
                                            const imagePromise = book.archive.getBase64(internalResolvedPath)
                                                .then(base64Data => {
                                                    if (base64Data) {
                                                        // 3. Base64 데이터를 바탕으로 Data URL 생성
                                                        const newDataUrl = `data:${mimeType};base64,${base64Data}`;
                                                        // 4. 생성된 Data URL을 xlink:href 속성에 적용
                                                        svgImg.setAttributeNS('http://www.w3.org/1999/xlink', 'href', newDataUrl);
                                                        console.log(`DEBUG:   SVG Image #${index} - Base64 obtained. New xlink:href (data URL, snippet): ${newDataUrl.substring(0, 100)}...`);
                                                        console.log(`DEBUG:   SVG Image #${index} - outerHTML AFTER change (from async update): ${svgImg.outerHTML}`); // 변경 후 확인
                                                    } else {
                                                        console.warn(`DEBUG:   SVG Image #${index} - Base64 data not found for path: ${internalResolvedPath}`);
                                                    }
                                                })
                                                .catch(error => {
                                                    console.error(`DEBUG:   SVG Image #${index} - Error getting Base64 for ${internalResolvedPath}:`, error);
                                                });
                                            imageProcessingPromises.push(imagePromise);
                                        }
                                    });

                                    // 모든 이미지 처리가 완료될 때까지 기다린 후 HTML 반환
                                    return Promise.all(imageProcessingPromises).then(() => {
                                        extractedHtml = tempDiv.innerHTML; // 수정된 HTML 문자열 다시 읽어오기
                                        console.log(`DEBUG: Final tempDiv.innerHTML (XMLDocument branch, first 500 chars): ${extractedHtml.substring(0, 500)}...`); 
                                        return extractedHtml; // 이 섹션의 최종 HTML 반환
                                    });

                                } else if (typeof loadedContent === 'string') {
                                    console.log(`DEBUG: Loaded content is string for ${item.href}`);

                                    // HTML 문자열인 경우에도 head/title 제거 시도
                                    extractedHtml = loadedContent.replace(/<head[^>]*>[\s\S]*?<\/head>/i, '');
                                    extractedHtml = extractedHtml.replace(/<title[^>]*>[\s\S]*?<\/title>/i, '');
                                    
                                    // 이미지 경로 변환 로직 (문자열 파싱 후)
                                    const tempDiv = document.createElement('div');
                                    tempDiv.innerHTML = extractedHtml;
                                    
                                    const svgImages = tempDiv.querySelectorAll('svg image');
                                    console.log(`DEBUG: Found ${svgImages.length} svg image elements in tempDiv (string branch).`);

                                    const imageProcessingPromises = []; // 문자열 브랜치에서도 비동기 처리

                                    svgImages.forEach((svgImg, index) => {
                                        const originalXlinkHref = svgImg.getAttributeNS('http://www.w3.org/1999/xlink', 'href'); 
                                        console.log(`DEBUG:   SVG Image #${index} (string) - Original outerHTML BEFORE change: ${svgImg.outerHTML}`);

                                        if (originalXlinkHref && !originalXlinkHref.startsWith('http') && !originalXlinkHref.startsWith('data:')) {
                                            let internalResolvedPath;
                                            try {
                                                internalResolvedPath = new URL(originalXlinkHref, item.href).toString();
                                            } catch (e) {
                                                console.error(`URL 해석 오류 (string, originalXlinkHref: ${originalXlinkHref}, item.href: ${item.href}):`, e);
                                                return;
                                            }

                                            console.log(`DEBUG:   SVG Image #${index} (string) - 내부 해결된 경로: ${internalResolvedPath}`);
                                            const mimeType = getMimeType(internalResolvedPath);

                                            const imagePromise = book.archive.getBase64(internalResolvedPath)
                                                .then(base64Data => {
                                                    if (base64Data) {
                                                        const newDataUrl = `data:${mimeType};base64,${base64Data}`;
                                                        svgImg.setAttributeNS('http://www.w3.org/1999/xlink', 'href', newDataUrl);
                                                        console.log(`DEBUG:   SVG Image #${index} (string) - Base64 obtained. New xlink:href (data URL, snippet): ${newDataUrl.substring(0, 100)}...`);
                                                        console.log(`DEBUG:   SVG Image #${index} (string) - outerHTML AFTER change (from async update): ${svgImg.outerHTML}`);
                                                    } else {
                                                        console.warn(`DEBUG:   SVG Image #${index} (string) - Base64 data not found for path: ${internalResolvedPath}`);
                                                    }
                                                })
                                                .catch(error => {
                                                    console.error(`DEBUG:   SVG Image #${index} (string) - Error getting Base64 for ${internalResolvedPath}:`, error);
                                                });
                                            imageProcessingPromises.push(imagePromise);
                                        }
                                    });

                                    return Promise.all(imageProcessingPromises).then(() => {
                                        extractedHtml = tempDiv.innerHTML;
                                        console.log(`DEBUG: Final tempDiv.innerHTML (string branch, first 500 chars): ${extractedHtml.substring(0, 500)}...`);
                                        return extractedHtml;
                                    });

                                } else {
                                    console.warn(`섹션 '${item.href}'의 콘텐츠 형식을 알 수 없습니다.`, loadedContent);
                                    return Promise.resolve(""); // 알 수 없는 콘텐츠도 Promise로 감싸서 반환
                                }
                            })
                            .catch(error => {
                                console.error(`섹션 '${item.href}' 로드 중 오류:`, error);
                                return Promise.resolve(""); // 오류 발생 시에도 Promise로 빈 문자열 반환
                            });
                    });

                    // 모든 섹션의 HTML 추출 및 이미지 처리가 완료될 때까지 기다립니다.
                    Promise.all(htmlExtractionPromises)
                        .then(function(htmls) {
                            let fullHtmlContent = htmls.join("<hr style='margin: 30px 0; border-top: 2px dashed #eee;'>");
                            console.log("--- EPUB 전체 HTML 추출 완료 ---");
                            const extractedTextArea = document.getElementById("extracted-text-area");
                            if (extractedTextArea) {
                                extractedTextArea.innerHTML = fullHtmlContent;
                            }
                        })
                        .catch(function(error) {
                            console.error("HTML 추출 과정 중 오류 (Promise.all catch 블록):", error);
                            const extractedTextArea = document.getElementById("extracted-text-area");
                            if (extractedTextArea) {
                                extractedTextArea.innerText = "HTML 추출 중 오류 발생: " + error.message;
                            }
                        });

                }).catch(function(error) {
                    console.error("책 로드 준비 중 오류:", error);
                    const extractedTextArea = document.getElementById("extracted-text-area");
                    if (extractedTextArea) {
                        extractedTextArea.innerText = "EPUB 파일을 로드하는 데 실패했습니다: " + error.message;
                    }
                });

            } catch (e) {
                console.error("EPUB 뷰어 라이브러리 로드 또는 초기화 중 오류 발생:", e);
                const extractedTextArea = document.getElementById("extracted-text-area");
                if (extractedTextArea) {
                    extractedTextArea.innerText = "EPUB 뷰어 라이브러리 로드 또는 초기화 중 오류 발생: " + e.message;
                }
            }
        </script>
    </main>
</body>
</html>