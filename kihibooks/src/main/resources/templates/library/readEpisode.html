<!DOCTYPE html>
<html
    xmlns:th="http://www.thymeleaf.org"
    xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
    xmlns:sec="http://www.thymeleaf.org/extras/spring-security"
    layout:decorate="~{layout/layout.html}">
<head>
    <meta charset="UTF-8">
    <title>EPUB ì½ê¸°</title>
    <style>
        #epub-area {
            width: 800px;
            height: 600px; /* ê³ ì • ë†’ì´ ì„¤ì • */
            margin: 20px auto;
            border: 2px solid #ddd; /* í…Œë‘ë¦¬ ìƒ‰ìƒ ë³€ê²½ */
            background-color: #f9f9f9; /* ë°°ê²½ìƒ‰ ë³€ê²½ */
            overflow-y: hidden; /* Epub.jsê°€ ë‚´ë¶€ì ìœ¼ë¡œ ìŠ¤í¬ë¡¤ì„ ì²˜ë¦¬í•˜ë¯€ë¡œ hidden */
            position: relative;
        }
        .series-container {
            margin-top: 30px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            text-align: center; /* ë²„íŠ¼ ì¤‘ì•™ ì •ë ¬ì„ ìœ„í•´ ì¶”ê°€ */
        }
        #extracted-text-area {
            margin-top: 20px;
            border: 1px dashed #ccc;
            padding: 10px;
            /* white-space: pre-wrap; ì œê±° - HTMLì„ ë Œë”ë§í•  ê²ƒì´ë¯€ë¡œ */
            max-height: 500px; /* ë†’ì´ ì„¤ì • ìœ ì§€ */
            overflow-y: auto; /* ë‚´ìš©ì´ ë„˜ì¹  ê²½ìš° ìŠ¤í¬ë¡¤ë°” í‘œì‹œ */
            text-align: left; /* í…ìŠ¤íŠ¸ëŠ” ì™¼ìª½ ì •ë ¬ */
            min-height: 500px; /* ìµœì†Œ ë†’ì´ ìœ ì§€ */
            background-color: #ffffff; /* ë°°ê²½ìƒ‰ ì„¤ì • */
            box-sizing: border-box; /* íŒ¨ë”©ì´ ë„ˆë¹„ì— í¬í•¨ë˜ë„ë¡ */
        }
        /* ì¶”ì¶œëœ HTML ë‚´ì˜ SVG Image ìŠ¤íƒ€ì¼ */
        #extracted-text-area svg image {
            max-width: 100%; /* ì´ë¯¸ì§€ê°€ ë¶€ëª¨ ì»¨í…Œì´ë„ˆë¥¼ ë„˜ì§€ ì•Šë„ë¡ */
            height: auto;
            display: block; /* ì´ë¯¸ì§€ í•˜ë‹¨ ì—¬ë°± ì œê±° */
            margin: 5px auto; /* ì´ë¯¸ì§€ ì¤‘ì•™ ì •ë ¬ ë° ìƒí•˜ ì—¬ë°± */
            border: 1px solid #eee; /* ì´ë¯¸ì§€ê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ê¸° ìœ„í•œ í…Œë‘ë¦¬ */
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #0056b3;
        }
        /* ê¸°ì¡´ ìŠ¤íƒ€ì¼ ìœ ì§€ ë° í•„ìš”í•œ ê²½ìš° ì¡°ì • */
        .content-management-page h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            border-bottom: 2px solid #ff7f50;
            padding-bottom: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <main layout:fragment="content">
        <div class="container content-management-page">
            <h2 class="mb-3">ğŸ“– EPUB ì½ê¸°</h2>
            <p>ì—í”¼ì†Œë“œ ì½”ë“œ: <span th:text="${epCode}"></span></p>
            <input type="hidden" th:value="${epCode}" id="epCode">
            <input type="hidden" th:value="${boCode}" id="boCode">

            <div class="series-container">
                <div id="extracted-text-area">
                    EPUB ë‚´ìš© ì¶”ì¶œ ê²°ê³¼ê°€ ì—¬ê¸°ì— HTML í˜•ì‹ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤.
                    (ì´ë¯¸ì§€ ë¡œë”© ì—¬ë¶€ëŠ” ì½˜ì†”ì„ í™•ì¸í•´ì£¼ì„¸ìš”)
                </div>

                <div id="epub-area"></div>
                <div style="margin-top: 10px;">
                    <button id="prevBtn">ì´ì „ í˜ì´ì§€</button>
                    <button id="nextBtn">ë‹¤ìŒ í˜ì´ì§€</button>
                </div>
            </div>
        </div>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        
        <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
        
        <script src="https://unpkg.com/xmldom@0.6.0/dom-parser.js"></script>
        
        <script src="/resources/static/js/epub.min.js"></script>

        <script>
            console.log(">>> ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ ì™„ë£Œ! ë””ë²„ê¹… ì •ë³´ <<<");
            console.log("JSZip ê°ì²´ íƒ€ì…:", typeof JSZip); 
            console.log("DOMParser ê°ì²´ íƒ€ì…:", typeof DOMParser); 
            console.log("Epub.js ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ ì§í›„ ePub ê°ì²´ íƒ€ì…:", typeof ePub); 
            console.log("Epub.js ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ ì§í›„ window.ePub ê°ì²´ íƒ€ì…:", typeof window.ePub); 
            console.log(">>> ë””ë²„ê¹… ì •ë³´ ë <<<");
        </script>

        <script th:inline="javascript">
            // íŒŒì¼ í™•ì¥ìì— ë”°ë¥¸ MIME íƒ€ì… ë°˜í™˜ í—¬í¼ í•¨ìˆ˜
            function getMimeType(filename) {
                const ext = filename.split('.').pop().toLowerCase();
                switch (ext) {
                    case 'jpg':
                    case 'jpeg': return 'image/jpeg';
                    case 'png': return 'image/png';
                    case 'gif': return 'image/gif';
                    case 'svg': return 'image/svg+xml';
                    case 'bmp': return 'image/bmp';
                    case 'webp': return 'image/webp';
                    default: return 'application/octet-stream'; // ì•Œ ìˆ˜ ì—†ëŠ” ê²½ìš° ê¸°ë³¸ê°’
                }
            }

            const epCode = $("#epCode").val();
            const boCode = $("#boCode").val();
            console.log("ê°€ì ¸ì˜¨ ì—í”¼ì†Œë“œ ì½”ë“œ:", epCode);
            console.log("ê°€ì ¸ì˜¨ ì±… ì½”ë“œ:", boCode);

            const epubFileUrl = "/file/" + boCode + "/epubs/" + epCode + ".epub";
            console.log("EPUB íŒŒì¼ì„ ê°€ì ¸ì˜¬ URL:", epubFileUrl);

            try {
                const EpubConstructor = typeof ePub !== 'undefined' ? ePub : Epub;
                if (typeof EpubConstructor !== 'function') {
                    throw new Error("ePub.js ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì „ì—­ì— 'ePub' ë˜ëŠ” 'Epub' ê°ì²´ë¥¼ ì •ì˜í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
                }

                const book = new EpubConstructor(epubFileUrl);
                console.log("Epub ê°ì²´ ìƒì„±ë¨:", book);

                book.ready.then(function() {
                    console.log("ì±… ë¡œë“œ ë° íŒŒì‹± ì™„ë£Œ!");

                    const rendition = book.renderTo("epub-area", {
                        width: "800px",
                        height: "600px",
                        flow: "scrolled-doc",
                        manager: "default"
                    });
                    rendition.display();

                    document.getElementById("nextBtn").addEventListener("click", function(){
                        rendition.next();
                        console.log("ë‹¤ìŒ í˜ì´ì§€ë¡œ ì´ë™");
                    });
                    document.getElementById("prevBtn").addEventListener("click", function(){
                        rendition.prev();
                        console.log("ì´ì „ í˜ì´ì§€ë¡œ ì´ë™");
                    });

                    const spineItems = book.spine.items;
                    console.log("ì±…ì— ìˆëŠ” ì„¹ì…˜/ì±•í„° ìˆ˜:", spineItems.length);
                    
                    const htmlExtractionPromises = spineItems.map(function(item) {
                        console.log(`--- ì„¹ì…˜ ì²˜ë¦¬ ì‹œì‘: ${item.href} ---`);

                        return book.load(item.href)
                            .then(loadedContent => { 
                                let extractedHtml = "";
                                
                                if (loadedContent && typeof loadedContent.documentElement === 'object' && loadedContent.documentElement.nodeName) {
                                    const serializer = new XMLSerializer();
                                    extractedHtml = serializer.serializeToString(loadedContent);

                                    console.log(`DEBUG: Loaded content is XMLDocument object for ${item.href}`);

                                    // head ë° title íƒœê·¸ ë‚´ìš© ì œê±°
                                    extractedHtml = extractedHtml.replace(/<head[^>]*>[\s\S]*?<\/head>/i, '');
                                    extractedHtml = extractedHtml.replace(/<title[^>]*>[\s\S]*?<\/title>/i, '');

                                    const tempDiv = document.createElement('div');
                                    tempDiv.innerHTML = extractedHtml; // Parse the HTML string into a temporary DOM

                                    // SVG ë‚´ë¶€ì˜ <image> íƒœê·¸ xlink:href ì†ì„± ì²˜ë¦¬
                                    const svgImages = tempDiv.querySelectorAll('svg image');
                                    console.log(`DEBUG: Found ${svgImages.length} svg image elements in tempDiv (XMLDocument branch).`);

                                    // ê° ì´ë¯¸ì§€ ì²˜ë¦¬ëŠ” ë¹„ë™ê¸°ì´ë¯€ë¡œ Promise.allë¡œ ë¬¶ìŠµë‹ˆë‹¤.
                                    const imageProcessingPromises = [];

                                    svgImages.forEach((svgImg, index) => {
                                        const originalXlinkHref = svgImg.getAttributeNS('http://www.w3.org/1999/xlink', 'href'); 
                                        console.log(`DEBUG:   SVG Image #${index} - Original outerHTML BEFORE change: ${svgImg.outerHTML}`);

                                        // ì´ë¯¸ httpë‚˜ data:ë¡œ ì‹œì‘í•˜ëŠ” ê²½ìš° ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€
                                        if (originalXlinkHref && !originalXlinkHref.startsWith('http') && !originalXlinkHref.startsWith('data:')) {
                                            let internalResolvedPath;
                                            try {
                                                // 1. item.hrefë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìƒëŒ€ ê²½ë¡œë¥¼ ë¨¼ì € EPUB ë‚´ë¶€ì˜ 'ì ˆëŒ€' ê²½ë¡œí™”
                                                internalResolvedPath = new URL(originalXlinkHref, item.href).toString();
                                            } catch (e) {
                                                console.error(`URL í•´ì„ ì˜¤ë¥˜ (originalXlinkHref: ${originalXlinkHref}, item.href: ${item.href}):`, e);
                                                return; // ì´ ì´ë¯¸ì§€ ì²˜ë¦¬ë¥¼ ê±´ë„ˆë›°ê³  ë‹¤ìŒ ì´ë¯¸ì§€ë¡œ ë„˜ì–´ê°
                                            }
                                            
                                            console.log(`DEBUG:   SVG Image #${index} - ë‚´ë¶€ í•´ê²°ëœ ê²½ë¡œ: ${internalResolvedPath}`);
                                            const mimeType = getMimeType(internalResolvedPath); // MIME íƒ€ì… ì¶”ë¡ 

                                            // 2. book.archive.getBase64()ë¥¼ í†µí•´ ì´ë¯¸ì§€ Base64 ë°ì´í„° ì§ì ‘ ì–»ê¸° (ë¹„ë™ê¸°)
                                            const imagePromise = book.archive.getBase64(internalResolvedPath)
                                                .then(base64Data => {
                                                    if (base64Data) {
                                                        // 3. Base64 ë°ì´í„°ë¥¼ ë°”íƒ•ìœ¼ë¡œ Data URL ìƒì„±
                                                        const newDataUrl = `data:${mimeType};base64,${base64Data}`;
                                                        // 4. ìƒì„±ëœ Data URLì„ xlink:href ì†ì„±ì— ì ìš©
                                                        svgImg.setAttributeNS('http://www.w3.org/1999/xlink', 'href', newDataUrl);
                                                        console.log(`DEBUG:   SVG Image #${index} - Base64 obtained. New xlink:href (data URL, snippet): ${newDataUrl.substring(0, 100)}...`);
                                                        console.log(`DEBUG:   SVG Image #${index} - outerHTML AFTER change (from async update): ${svgImg.outerHTML}`); // ë³€ê²½ í›„ í™•ì¸
                                                    } else {
                                                        console.warn(`DEBUG:   SVG Image #${index} - Base64 data not found for path: ${internalResolvedPath}`);
                                                    }
                                                })
                                                .catch(error => {
                                                    console.error(`DEBUG:   SVG Image #${index} - Error getting Base64 for ${internalResolvedPath}:`, error);
                                                });
                                            imageProcessingPromises.push(imagePromise);
                                        }
                                    });

                                    // ëª¨ë“  ì´ë¯¸ì§€ ì²˜ë¦¬ê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦° í›„ HTML ë°˜í™˜
                                    return Promise.all(imageProcessingPromises).then(() => {
                                        extractedHtml = tempDiv.innerHTML; // ìˆ˜ì •ëœ HTML ë¬¸ìì—´ ë‹¤ì‹œ ì½ì–´ì˜¤ê¸°
                                        console.log(`DEBUG: Final tempDiv.innerHTML (XMLDocument branch, first 500 chars): ${extractedHtml.substring(0, 500)}...`); 
                                        return extractedHtml; // ì´ ì„¹ì…˜ì˜ ìµœì¢… HTML ë°˜í™˜
                                    });

                                } else if (typeof loadedContent === 'string') {
                                    console.log(`DEBUG: Loaded content is string for ${item.href}`);

                                    // HTML ë¬¸ìì—´ì¸ ê²½ìš°ì—ë„ head/title ì œê±° ì‹œë„
                                    extractedHtml = loadedContent.replace(/<head[^>]*>[\s\S]*?<\/head>/i, '');
                                    extractedHtml = extractedHtml.replace(/<title[^>]*>[\s\S]*?<\/title>/i, '');
                                    
                                    // ì´ë¯¸ì§€ ê²½ë¡œ ë³€í™˜ ë¡œì§ (ë¬¸ìì—´ íŒŒì‹± í›„)
                                    const tempDiv = document.createElement('div');
                                    tempDiv.innerHTML = extractedHtml;
                                    
                                    const svgImages = tempDiv.querySelectorAll('svg image');
                                    console.log(`DEBUG: Found ${svgImages.length} svg image elements in tempDiv (string branch).`);

                                    const imageProcessingPromises = []; // ë¬¸ìì—´ ë¸Œëœì¹˜ì—ì„œë„ ë¹„ë™ê¸° ì²˜ë¦¬

                                    svgImages.forEach((svgImg, index) => {
                                        const originalXlinkHref = svgImg.getAttributeNS('http://www.w3.org/1999/xlink', 'href'); 
                                        console.log(`DEBUG:   SVG Image #${index} (string) - Original outerHTML BEFORE change: ${svgImg.outerHTML}`);

                                        if (originalXlinkHref && !originalXlinkHref.startsWith('http') && !originalXlinkHref.startsWith('data:')) {
                                            let internalResolvedPath;
                                            try {
                                                internalResolvedPath = new URL(originalXlinkHref, item.href).toString();
                                            } catch (e) {
                                                console.error(`URL í•´ì„ ì˜¤ë¥˜ (string, originalXlinkHref: ${originalXlinkHref}, item.href: ${item.href}):`, e);
                                                return;
                                            }

                                            console.log(`DEBUG:   SVG Image #${index} (string) - ë‚´ë¶€ í•´ê²°ëœ ê²½ë¡œ: ${internalResolvedPath}`);
                                            const mimeType = getMimeType(internalResolvedPath);

                                            const imagePromise = book.archive.getBase64(internalResolvedPath)
                                                .then(base64Data => {
                                                    if (base64Data) {
                                                        const newDataUrl = `data:${mimeType};base64,${base64Data}`;
                                                        svgImg.setAttributeNS('http://www.w3.org/1999/xlink', 'href', newDataUrl);
                                                        console.log(`DEBUG:   SVG Image #${index} (string) - Base64 obtained. New xlink:href (data URL, snippet): ${newDataUrl.substring(0, 100)}...`);
                                                        console.log(`DEBUG:   SVG Image #${index} (string) - outerHTML AFTER change (from async update): ${svgImg.outerHTML}`);
                                                    } else {
                                                        console.warn(`DEBUG:   SVG Image #${index} (string) - Base64 data not found for path: ${internalResolvedPath}`);
                                                    }
                                                })
                                                .catch(error => {
                                                    console.error(`DEBUG:   SVG Image #${index} (string) - Error getting Base64 for ${internalResolvedPath}:`, error);
                                                });
                                            imageProcessingPromises.push(imagePromise);
                                        }
                                    });

                                    return Promise.all(imageProcessingPromises).then(() => {
                                        extractedHtml = tempDiv.innerHTML;
                                        console.log(`DEBUG: Final tempDiv.innerHTML (string branch, first 500 chars): ${extractedHtml.substring(0, 500)}...`);
                                        return extractedHtml;
                                    });

                                } else {
                                    console.warn(`ì„¹ì…˜ '${item.href}'ì˜ ì½˜í…ì¸  í˜•ì‹ì„ ì•Œ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, loadedContent);
                                    return Promise.resolve(""); // ì•Œ ìˆ˜ ì—†ëŠ” ì½˜í…ì¸ ë„ Promiseë¡œ ê°ì‹¸ì„œ ë°˜í™˜
                                }
                            })
                            .catch(error => {
                                console.error(`ì„¹ì…˜ '${item.href}' ë¡œë“œ ì¤‘ ì˜¤ë¥˜:`, error);
                                return Promise.resolve(""); // ì˜¤ë¥˜ ë°œìƒ ì‹œì—ë„ Promiseë¡œ ë¹ˆ ë¬¸ìì—´ ë°˜í™˜
                            });
                    });

                    // ëª¨ë“  ì„¹ì…˜ì˜ HTML ì¶”ì¶œ ë° ì´ë¯¸ì§€ ì²˜ë¦¬ê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦½ë‹ˆë‹¤.
                    Promise.all(htmlExtractionPromises)
                        .then(function(htmls) {
                            let fullHtmlContent = htmls.join("<hr style='margin: 30px 0; border-top: 2px dashed #eee;'>");
                            console.log("--- EPUB ì „ì²´ HTML ì¶”ì¶œ ì™„ë£Œ ---");
                            const extractedTextArea = document.getElementById("extracted-text-area");
                            if (extractedTextArea) {
                                extractedTextArea.innerHTML = fullHtmlContent;
                            }
                        })
                        .catch(function(error) {
                            console.error("HTML ì¶”ì¶œ ê³¼ì • ì¤‘ ì˜¤ë¥˜ (Promise.all catch ë¸”ë¡):", error);
                            const extractedTextArea = document.getElementById("extracted-text-area");
                            if (extractedTextArea) {
                                extractedTextArea.innerText = "HTML ì¶”ì¶œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: " + error.message;
                            }
                        });

                }).catch(function(error) {
                    console.error("ì±… ë¡œë“œ ì¤€ë¹„ ì¤‘ ì˜¤ë¥˜:", error);
                    const extractedTextArea = document.getElementById("extracted-text-area");
                    if (extractedTextArea) {
                        extractedTextArea.innerText = "EPUB íŒŒì¼ì„ ë¡œë“œí•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: " + error.message;
                    }
                });

            } catch (e) {
                console.error("EPUB ë·°ì–´ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ ë˜ëŠ” ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", e);
                const extractedTextArea = document.getElementById("extracted-text-area");
                if (extractedTextArea) {
                    extractedTextArea.innerText = "EPUB ë·°ì–´ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ ë˜ëŠ” ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ: " + e.message;
                }
            }
        </script>
    </main>
</body>
</html>